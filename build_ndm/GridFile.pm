#!/usr/local/bin/perl
#===============================================================================
#
# PROGRAM:             %M%
#
# VERSION:             %I%
#
# WHAT STRING:         %W%
#
# DESCRIPTION:         Perl module to interpolate from a gridded model in
#                      a binary file generated by makegrid.pl.  
#
# DEPENDENCIES:        
#
# MODIFICATION HISTORY
# NAME                 DATE        DESCRIPTION
# ===================  ==========  ============================================
# Chris Crook          03/02/2004  Created
#===============================================================================

package GridFile;

use strict;
use FileHandle;
use Unpacker;
use POSIX;

# Each possible grid file format has a specified header record.  Valid records
# are listed here.  The %formats hash converts these to a format definition
# string - one of GEOID (old SNAP geoid format), GRID1L (little endian version
# 1 grid format), GRID1B (big endian version 1 grid format).

my $siggeoid =  "SNAP geoid binary file\r\n\x1A";
my $siggrid1l = "SNAP grid binary v1.0 \r\n\x1A";
my $siggrid1b = "CRS grid binary v1.0  \r\n\x1A";
my $siggrid2l = "SNAP grid binary v2.0 \r\n\x1A";
my $siggrid2b = "CRS grid binary v2.0  \r\n\x1A";

my %formats = (
    $siggeoid=>'GEOID',
    $siggrid1l=>'GRID1L',
    $siggrid1b=>'GRID1B',
    $siggrid2l=>'GRID2L',
    $siggrid2b=>'GRID2B' );

my $siglen = length($siggeoid);

my @reqheader = qw/FORMAT HEADER0 HEADER1 HEADER2 CRDSYS NGRDX NGRDY XMIN XMAX YMIN YMAX VRES NDIM VALUES/;


sub new {
   my ($class, $filename) = @_;
   

   # Open the  grid file in binary mode.
   
   my $fh = new FileHandle;
   $fh->open($filename,'r') || die "Cannot open grid file $filename\n";
   binmode($fh);

   my $self = {
       filename=>$filename,
       fh=>$fh,
       titles=>["Grid data from file $filename"],
       nval=>1,
       vres=>1.0,
       crdsyscode=>'NONE',
       offset=>0,
       embedded=>0
       };

   bless $self, $class;
  
   $self->Setup;

   if( $self->{ngridx} < 2 || $self->{ngridy} < 2 ) {
       die "Invalid grid definition in grid file $filename\n";
       }

   return $self;
   }

sub newEmbedded {
   my ($class, $fh, $offset ) = @_;

   my $self = {
       filename=>'Embedded',
       fh=>$fh,
       titles=>["Grid data from embedded file"],
       nval=>1,
       vres=>1.0,
       crdsyscode=>'NONE',
       offset=>$offset,
       embedded=>1
       };

   bless $self, $class;
  
   seek($fh,$offset,0);

   $self->Setup;

   return $self;
   }


# Default set up for a LINZ grid file

sub Setup {
   my ($self) = @_;

   my $filename = $self->{filename};
   my $fh = $self->{fh};
  
   # Read the grid file signature and ensure that it is valid
   
   my $testsig;
   read($fh,$testsig,$siglen);
   
   my $fmt = $formats{$testsig};

   if( ! $fmt )
   {
       if( $testsig =~ /^(\w+)\:/  && 
             grep { $_ eq uc($1) } (@reqheader,'COMMENT') )
       {
           $self->SetupAscii();
           return;
       }
   }
   
   die "$filename is not a valid grid file - signature incorrect\n" if ! $fmt;
   
   my $filebigendian = $fmt eq 'GRID1B' || $fmt eq 'GRID2B';
   my $unpacker = new Unpacker($filebigendian,$fh);

   # Format of each row ..


   my $rowfmt = $self->GetRowFormat($fmt);
   
   # Read location in the file of the grid index data
   
   my $loc = $unpacker->read_long;
   die "Grid file not completed\n" if ! $loc;
   
   # Jump to the index and  read the grid data
   
   seek($fh,$loc+$self->{offset},0);
   
   my ($ymn,$ymx,$xmn,$xmx,$vres) = $unpacker->read_double(5);
   my ($ny,$nx) = $unpacker->read_short(2);
   
   # If the format is 'GEOID'  then two fields are not in the file, they
   # are set to default values.
   
   my( $dim, $latlon);
   if( $fmt ne 'GEOID' ) {
      ($dim,$latlon)=$unpacker->read_short(2);
      }
   else {
      $dim = 1;
      $latlon = 1;
      }
   
   # Read the grid descriptive data
   
   my ($s1,$s2,$s3,$s4) = $unpacker->read_string(4);
   
   # Read the file location of each row of data in the file..
   
   my @locs=$unpacker->read_long($ny);
   
   # Calculate the size of a buffer representing an entire row
   
   my $rowsize = $nx*$dim;

   # Store the generic grid file info

   $self->{format} = $fmt;
   $self->SetTitles($s1,$s2,$s3);
   $self->SetCrdSysCode( $s4 );
   $self->SetGridExtents( $xmn, $xmx, $nx, $ymn, $ymx, $ny, $latlon );
   $self->SetDimension( $dim );

   # Store the information specific to LINZ grid files

   $self->{locdata} = \@locs;
   $self->{rowsize} = $rowsize;
   $self->{rowfmt} = $rowfmt;
   $self->{data} = {};
   $self->{vres} = $vres;
   $self->{output_vres} = $vres;
   $self->{unpacker} = $unpacker;
   }


# For the ASCI version of the grid file, read the header information
# and locate the row data for each columns.

sub SetupAscii 
{
    my($self) = @_;
    my $inrec;
    my $fh = $self->{fh};
    seek($fh,0,0);
    my %headers = (NDIM=>1, LATLON=>1, HEADER1=>'', HEADER2=>'', VALUES=>'REAL');
    my $fileloc = 0;
    while($inrec = <$fh>){
       last if $inrec =~ /^\s*v\d+\,\d+\:/i;
       $inrec =~ s/\s*$//;
       $headers{uc($1)} = $2 if $inrec =~ /^\s*(\w+)\s*\:\s*(.*?)\s*$/;
       $fileloc = tell($fh);
       }
    my @missing = grep {! defined($headers{$_})} @reqheader;
    die "Definition file missing records ",join(' ',@missing),"\n" if @missing;

    # Test for invalid input data
    
    die "Invalid format $headers{FORMAT}\n" 
        if ! grep {uc($headers{FORMAT}) eq $_ } values %formats;
    die "Invalid CRDSYS definition $headers{CRDSYS}\n" if $headers{CRDSYS} !~ /^\w+$/;
    my $ngrdx = $headers{NGRDX}+0;
    my $ngrdy = $headers{NGRDY}+0;
    my $vres = $headers{VRES};
    $vres = 0 if uc($vres) eq 'AUTO';
    $vres += 0;
    my $ndim = $headers{NDIM}+0;
    die "Invalid row or column count\n" if $ngrdx < 1 || $ngrdy < 1;
    die "Invalid resolution\n" if $vres < 0.0;
    die "Invalid grid element dimension\n" if $ndim < 1;

    $self->SetTitles(@headers{qw/HEADER0 HEADER1 HEADER2/});
    $self->SetCrdSysCode( $headers{CRDSYS} );
    $self->SetGridExtents(@headers{qw/XMIN XMAX NGRDX YMIN YMAX NGRDY LATLON/});
    $self->SetDimension( $ndim );
    $self->{format} = 'ASCII';
    $self->{output_format} = $headers{FORMAT};
    $self->{output_vres} = $vres;

    my $ny = $headers{NGRDY}+0;
    my @locdata = (-1) x $ny;

    my $row = -1;

    while( $inrec =~ /^\s*v\d+\,(\d+)\:/i)
    {
        if( $1 != $row ){ $row = $1; $locdata[$row-1]=$fileloc;}
        $fileloc = tell($fh);
        $inrec = <$fh>;
    }

    $self->{locdata} = \@locdata;
    $self->{rowsize} = 0;
    $self->{rowfmt} = 0;
    $self->{data} = {};
    $self->{vres} = $headers{VALUES} eq 'REAL' ? 1.0 : $vres;
    $self->{unpacker} = undef;
}

sub GetRowFormat
{
    my ($self,$fmt) = @_;
    my $rowfmt = 1;
    $rowfmt = 2 if $fmt eq 'GRID2B' || $fmt eq 'GRID2L';
    $rowfmt = 0 if $fmt eq 'ASCII';
    return $rowfmt;
}


sub GetRow {
   my( $self, $row ) = @_;
   my $data = $self->{data};
   if( ! exists($data->{$row}) ) 
   {
      die "Invalid grid row $row requested from $self->{filename}\n"
        if $row < 0 || $row >= $self->{ngridy};
      my $fh = $self->{fh};
      my $loc = $self->{locdata}->[$row];
      seek($fh,$loc+$self->{offset},0);
      if( $self->{rowfmt} == 2 )
      {
         $data->{$row} = $self->GetRow2();
      }
      elsif( $self->{rowfmt} == 1 ) 
      {
         my $unpacker = $self->{unpacker};
         my $rowsize = $self->{rowsize};
         my @vals = $unpacker->read_short($rowsize);
         foreach my $v (@vals) { $v=undef if $v == 0x7FFF; }
         $data->{$row} = \@vals;
      }
      else
      {
          $self->GetRowAscii($row);
      }
   }
   return $data->{$row};
   }

sub GetRowAscii 
{
    my( $self, $row ) = @_;
    my $fh = $self->{fh};
    my $nx = $self->{ngridx};
    my $ndim = $self->{nval};
    my @data = (undef) x ($nx*$ndim);
    my $row1 = $row+1;
    while( my $inrec=<$fh> )
    {
        $inrec =~ s/\s+$//;
        last if $inrec !~ /^\s*v(\d+)\,(\d+)\:\s*(.*)$/i || $2 != $row1;
        my $col = $1;
        last if $col < 1 || $col > $nx;
        my $c = ($col-1)*$ndim;
        my @ptdata = split(' ',$3);
        for my $d (0..$ndim-1)
        {
            $data[$c+$d] = $ptdata[$d] if $ptdata[$d] ne '*';
        }
    }
    $self->{data}->{$row} = \@data;
}

sub GetRow2 {
   my($self) = @_;
   my $undefined = undef;
   my @data = ($undefined) x $self->{rowsize};
   my $unpacker = $self->{unpacker};

   my $ndim = $self->{nval};
   for my $idim (0..$ndim-1)
   {
      my $imin = 0;
      my $imax = 0;
      my $cont = 0;
      do 
      {
      my ($format) = $unpacker->read_short(1);
      my $subset = $format & 1;
      $cont = $format & 2;
      my $dif = ($format >> 2) & 3;
      my $bits = $format >> 4;
      my $undef2 = 2**($bits*8-1) - 1;
   
      last if $cont && ! $subset;

      $imax = $self->{ngridx}-1;
      ($imin,$imax) = $unpacker->read_short(2) if $subset;
      my $nval = ($imax-$imin)+1;
      my $d1 = $dif < 1 ? 0 : $unpacker->read_long(1);
      my $d2 = $dif < 2 ? 0 : $unpacker->read_long(1);
      my @v;
      if( $bits == 1 ) { @v = $unpacker->read_byte($nval); }
      elsif( $bits == 2 ) { @v = $unpacker->read_short($nval); }
      else { @v = $unpacker->read_long($nval);}

      if( $dif == 0 && $undefined != $undef2 )
      {
          foreach my $i (0 .. $nval-1) { $v[$i] = $undefined if $v[$i] == $undef2; }
      }
      elsif( $dif == 1 )
      {
          $v[0] = $d1;
          foreach my $i ( 1 .. $nval-1) 
          {
             if( $v[$i] == $undef2 ) { $v[$i] = $undefined; }
             else  { $d1 += $v[$i]; $v[$i] = $d1; }
          }
      }
      elsif( $dif == 2 )
      {
          $v[0] = $d1;
          foreach my $i ( 1 .. $nval-1) 
          {
             if( $v[$i] == $undef2 ) { $v[$i] = $undefined; }
             else  { $d2+= $v[$i]; $d1+=$d2; $v[$i] = $d1; }
          }
      }

      my $i0 = $imin*$ndim+$idim;
      foreach my $i (0 .. $nval-1 )
      {
          $data[$i0] = $v[$i];
          $i0 += $ndim;
      }
      } while ($cont);

   }

   return \@data;
   }


sub WriteToFile
{
    my($self,$filename,@options) = @_;
    my %options = ref($options[0]) ? %{$options[0]} : @options;
    my $fmt = $options{format} || $self->{output_format} || 
        ($self->{format} eq 'ASCII' ? 'GRID2L' : 'ASCII');
    $fmt = uc($fmt);
    die "Invalid grid output format $fmt\n"
        if $fmt ne 'ASCII'  && $fmt != 'CSV' && ! (grep {$_ eq $fmt} values %formats);
    $options{format} = $fmt;
    $options{rowformat} = $self->GetRowFormat( $fmt );

    # Define the output resolution - 0 implies calculate an optimal resolution
    # based on the maximum data value
    my $vres = $options{vres};
    $vres = $self->{output_vres} if ! defined $vres;
    $options{calcvres} = 1 if ! $vres;
    $options{vres} = $vres || $self->{vres};

    open(my $fh, ">$filename") || die "Cannot open output grid file $filename\n";
    eval
    {

    if( $fmt eq 'ASCII')
    {
        binmode($fh);
        $self->WriteAscii($fh,\%options);
    }
    elsif( $fmt eq 'CSV')
    {
        $self->WriteCsv($fh,\%options);
    }
    else
    {
        binmode($fh);
        use Packer;
        my $filebigendian = $fmt eq 'GRID1B' || $fmt eq 'GRID2B';
        my $packer = new Packer($filebigendian);
        $self->WriteBinary($fh,$packer,\%options);
    }
    };
    my $error = $@;
    close($fh);
    if( $error )
    {
        unlink($filename);
        die $error;
    }
}

sub WriteCsv
{
    my($self,$fh,$options) = @_;
    my $sep = $options->{separator} || ',';
    $sep = "\t" if $sep == "tab";
    my $header = $options->{header};
    if( $header eq '' )
    {
        $header = $self->{latlon} ? 'Lon Lat' : 'X Y';
        foreach my $i (1 ..$self->{nval} ) { $header .= " value$i"; }
    }
    print $fh join($sep,split(' ',$header)),"\n" if $header;
    my $ny = $self->{ngridy};
    my $undef = $options->{missingvalue};
    my $usemissing = 1 unless $options->{skipmissingvalues};
    my $pointids = $options->{pointids};
    my $ncol1 = $self->{nval} + 1;
    my @id=();
    my $nr = 0;
    foreach my $y (0..$ny-1)
    {
        $nr++;
        my $nc = 0;
        foreach my $d ( $self->RowData($y) )
        {
            $nc++;
            if( ! $usemissing )
            {
                next if grep { ! defined($d->[$_]) } (2..$ncol1);
            }
            @id = ($nc,$nr) if($pointids);
            print $fh join($sep,@id, map {defined($_) ? $_ : $undef } @$d),"\n";
        }
    }
}

sub WriteAscii
{
    my($self,$fh,$options) = @_;
    my $format = $self->{format} || 'GRID2L';
    $format = 'GRID2L' if $format eq 'ASCII';
    print $fh "FORMAT: $format\n";
    my @titles = $self->Title();
    print $fh "HEADER0: $titles[0]\n";
    print $fh "HEADER1: $titles[1]\n";
    print $fh "HEADER2: $titles[2]\n";
    print $fh "CRDSYS: ",$self->{crdsyscode},"\n";
    print $fh "NGRDX: ",$self->{ngridx},"\n";
    print $fh "NGRDY: ",$self->{ngridy},"\n";
    print $fh "XMIN: ",$self->{xmin},"\n";
    print $fh "XMAX: ",$self->{xmax},"\n";
    print $fh "YMIN: ",$self->{ymin},"\n";
    print $fh "YMAX: ",$self->{ymax},"\n";
    print $fh "VRES: ",$options->{vres},"\n";
    if($format ne 'GEOID')
    {
        print $fh "NDIM: ",$self->{nval},"\n";
        print $fh "LATLON: ",$self->{latlon} ? 1 : 0,"\n";
    }
    my $valuetype = 'INTEGER';
    $valuetype = 'REAL' if $options->{vres} == 1 || $options->{real};
    $options->{real} = 1 if $valuetype eq 'REAL';
    $options->{vres} = 1 if $valuetype eq 'REAL';
    print $fh "VALUES: $valuetype\n";

    return if $options->{headeronly};

    my $ny = $self->{ngridy};
    foreach my $row (0..$ny-1)
    {
        print $fh $self->BuildRow($row,undef,$options);
    }
}

sub WriteBinary
{
    my($self,$fh,$packer,$options) = @_;

    my $fmt = $options->{format};
    my ($sig) = grep { $formats{$_} eq $fmt } keys %formats;
    print $fh $sig;

    $options->{vres} = $self->CalcVres($fmt) if $options->{calcvres};

    my $indexptrloc = tell($fh);
    print $fh $packer->long(0);

    my @rowloc = ();

    my $ny = $self->{ngridy};

    foreach my $row (0..$ny-1)
    {
        $rowloc[$row] = tell($fh);
        print $fh $self->BuildRow($row,$packer,$options);
    }
    my $indexloc = tell($fh);
    print $fh $packer->double( @{$self}{qw/ymin ymax xmin xmax/}, $options->{vres} );
    print $fh $packer->short(@{$self}{qw/ngridy ngridx/} );
    print $fh $packer->short(@{$self}{qw/nval latlon/} ) if $fmt ne 'GEOID';
    my @titles = $self->Title();
    print $fh $packer->string($titles[0],$titles[1],$titles[2],$self->{crdsyscode});
    print $fh $packer->long(@rowloc);

    seek($fh,$indexptrloc,0);
    print $fh $packer->long($indexloc);
}

sub CalcVres
{
    my($self,$format) = @_;
    my $maxval = $self->MaxDataValue();
    my $maxival = ($format =~ /GRID1/ ? 0x7FFF : 0x7FFFFFFF);
    my $vres0 = $maxval/$maxival;
    $vres0 = 0.0000001 if $vres0 <= 0;
    my $vres = 1.0;
    $vres *= 10 while $vres < $vres0;
    $vres /= 10 while $vres > $vres0;
    $vres *= 2 if $vres < $vres0;
    $vres *= 2.5 if $vres < $vres0;
    $vres *= 2 if $vres < $vres0;
    return $vres;
}

sub BuildRow
{
  my($self,$row,$packer,$options) = @_;
  
  my $rowdata = $self->GetRow($row);
  my $nx = $self->{ngridx};
  my $ndim = $self->{nval};
  my $isint = ! $options->{real};
  my $vres = $options->{vres};
  $vres = 1 if ! $isint;
  my $factor = $self->{vres}/$vres;
  my @data2=();
  my $nrd = 0;
  my $rd = [];
  for my $i (0..$nx-1)
  {
      for my $id (0..$ndim-1)
      {
          my $vi = $rowdata->[$nrd];
          $nrd++;
          if( defined($vi) )
          {
              $vi *= $factor;
              $vi = floor($vi+0.5) if $isint;
          }
          $rd->[$id]->[$i] = $vi;
      }
  }

  my $rowfmt = $options->{rowformat};
  if( $rowfmt == 2 ) { return $self->BuildRowV2($packer,$rd); }
  if( $rowfmt == 0 ) { return $self->BuildRowAscii($rd,$row); }
  return $self->BuildRowV1($packer,$rd);
}

sub BuildRowAscii
{
    my ($self,$rowdata,$row) = @_;
    my @text = ();
    my $ndim = $self->{nval};
    my $nx = $self->{ngridx};
    for my $ix (0..$nx-1)
    {
        my @v = ();
        for my $id (0..$ndim-1)
        {
            my $v = $rowdata->[$id]->[$ix];
            $v = '*' if ! defined($v);
            push(@v,$v);
        }
        push(@text,
            sprintf("V%d,%d: ",$ix+1,$row+1).
            join(' ',@v).
            "\n")
    }
    return join('',@text);
}

sub BuildRowV1
{
  my($self,$packer,$rowdata) = @_;
  my $ndim = $self->{nval};
  my $ngrdx = $self->{ngridx};
  my $buffer = '';
  for my $row (0 .. $ngrdx-1) 
  {
    for my $idim (0 .. $ndim-1)
    {
      my $val = $rowdata->[$idim]->[$row];
      if( defined($val) )
      {
          $buffer .= $packer->short($val);
      }
      else
      {
          $buffer .= $packer->short(0x7FFF);
      }
     
    }
  }
  return $buffer;
}

sub BuildRowV2
{
  my($self,$packer,$rowdata) = @_;
  my $ndim = $self->{nval};
  my $ngrdx = $self->{ngridx};
  my $buffer = '';
  for my $idim ( 0..$ndim-1)
  {
     $buffer .= $self->BuildDataRowV2($packer,$rowdata->[$idim]);
  }
  return $buffer;
}

sub BuildDataRowV2
{
   my($self,$packer,$rowdata) = @_;
   my $ngrdx = $self->{ngridx};
   my ($max,$maxd,$maxd2) = (0,0,0);

   # Determine the ranges required to encode as 1st and 2nd differences

   my $rowdif = [];
   my $rowdif2 = [];

   my $undefined = 0x7FFFFFFF;

   my ($lastv, $lastd);
   my ($imin, $imax, $nval ) = (0,0,0);
   for my $i (0..$ngrdx-1)
   {
      my $v = $rowdata->[$i];
      if( ! defined($v) )
      {
         $rowdata->[$i] = $undefined;
         $rowdif->[$i] = $undefined;
         $rowdif2->[$i] = $undefined;
         next;
      }
      $rowdif->[$i] = 0;
      $rowdif2->[$i] = 0;

      $nval++;
      $imin = $i if $nval==1;
      $imax = $i;

      my $d = $v - $lastv;
      $d = 0 if $nval == 1;
      my $d2 = $d - $lastd;
      $d2 = 0 if $nval == 2;
      $rowdif->[$i]=$d;
      $rowdif2->[$i]=$d2;

      $lastv = $v;
      $lastd = $d;

      $v = abs($v);
      $d = abs($d);
      $d2 = abs($d2);
      $max = $v if $v > $max;
      $maxd = $d if $nval > 1 && $d > $maxd;
      $maxd2 = $d2 if $nval > 2 && $d2 > $maxd2;
   }

   my $bits = 1;
   $bits = 2 if $maxd2 > 0x7E;
   $bits = 4 if $maxd2 > 0x7FFE;
   $bits = 4 if $imax - $imin < 4;
   my $bmax = 2**($bits*8-1)-2;
   my $dif = 2;
   $dif = 1 if $maxd < $bmax;
   $dif = 0 if $max < $bmax;
   $dif = 0 if $bits == 4;
   my $subset = 0;
   $subset = 1 if $imin > 0 || $imax < $ngrdx-1;
   $subset = 2 if $nval == 0;
   my $format = ($bits*4+$dif)*4+$subset;
   my $buffer = $packer->short($format);
   return $buffer if $subset == 2;

   # If only storing a subset then save the first and last index
   if( $subset )
   {
      $buffer .= $packer->short($imin);
      $buffer .= $packer->short($imax);
   }

   # If using differences then output the initial values required
   # for differencing

   if( $dif )
   {
      $buffer .= $packer->long($rowdata->[$imin]);
      $rowdata = $rowdif;
      if( $dif == 2 )
      {
         for( my $i = $imin+1; $i<=$imax; $i++ ) 
         {
            next if $rowdif->[$i] == $undefined;
            $buffer .= $packer->long($rowdif->[$i]);
            last;
         }
         $rowdata = $rowdif2;
      }
   }

   # Set the undefined value to that appropriate to the number of bits.
   my $undef2 = 2**($bits*8-1)-1;
   for( my $i = 1; $i <= $ngrdx; $i++ )
   {
      $rowdata->[$i] = $undef2 if $rowdata->[$i] == $undefined;
   }

   # Output the data ..

   if( $subset )
   {
      my $rd = [];
      for my $i ($imin .. $imax) 
      { 
        push(@$rd,$rowdata->[$i]);
      }
      $rowdata = $rd;
   }
   if( $bits == 1 ){ $buffer .= $packer->char(@$rowdata); }
   elsif( $bits == 2 ) { $buffer .= $packer->short(@$rowdata); }
   else { $buffer .= $packer->long(@$rowdata); }

   return $buffer;
}

sub SetTitles {
   my ($self, @titles) = @_;
   $self->{titles} = \@titles;
   }

sub SetCrdSysCode {
   my ($self, $code ) = @_;
   $self->{crdsyscode} = $code;
   }

sub SetGridExtents {
   my($self,$xmin,$xmax,$ngrdx,$ymin,$ymax,$ngrdy,$latlon) = @_;
   if( $ngrdx < 2 || $ngrdy < 2 ) {
      my $filename = $self->{filename};
      die "$filename: Invalid grid extents\n";
      }

   my $xres = ($xmax - $xmin)/($ngrdx-1);
   my $yres = ($ymax - $ymin)/($ngrdy-1);

   my $global = 0;
   $global = 1 if $latlon && abs($ngrdx*$xres - 360) < 0.001;

   $self->{xmin} = $xmin;
   $self->{xmax} = $xmax;
   $self->{ymin} = $ymin;
   $self->{ymax} = $ymax;
   $self->{xres} = $xres;
   $self->{yres} = $yres;
   $self->{ngridx} = $ngrdx;
   $self->{ngridy} = $ngrdy;
   $self->{latlon} = $latlon;
   $self->{global} = $global;
   }

sub SetDimension {
   my ($self,$ndim) = @_;
   $self->{nval} = $ndim;
   }

sub DESTROY {
   my( $self ) = @_;
   if( ! $self->{embedded} ) {
     my $fh = $self->{fh};
     close($fh);
     }
   }

sub FileName {
   my ($self) = @_;
   return $self->{filename};
   }

sub Title {
   my ($self) = @_;
   return grep /\S/, @{$self->{titles}};
   }

sub CrdSysCode {
   my ($self) = @_;
   return $self->{crdsyscode};
   }

sub Range {
   my ($self) = @_;
   return @{$self}{ 'xmin', 'ymin', 'xmax', 'ymax' };
   }

sub GridSize {
   my ($self) = @_;
   return @{$self}{ 'ngridx', 'ngridy' };
   }

sub GridSpacing {
   my ($self) = @_;
   return @{$self}{ 'xres', 'yres', 'vres' };
   }

sub MaxDataValue {
   my ($self) = @_;
   my $nrow = $self->{ngridy};
   my $maxval = 0;
   for my $row (0..$nrow-1)
   {
       my $data = $self->GetRow($row);
       foreach my $d (@$data)
       {
           next if ! defined($d);
           my $ad = abs($d);
           $maxval = $ad if $ad > $maxval;
       }
   }
   return $maxval * $self->{vres};
   }


sub RowData {
   my ($self,$row,$col0,$col1) = @_;
   $col0 = 0 if ! defined($col0);
   $col1 = $self->{ngridx}-1 if ! defined($col1);
   die "Invalid row in GridFile::RowData\n"
     if $row < 0 || $row >= $self->{ngridy};
   die "Invalid column in GridFile::RowData\n"
     if $col0 > $col1 || $col0 < 0 || $col1 >= $self->{ngridx};
   my $data = $self->GetRow($row);
   my @result = ();
   my $nd =  $self->{nval};
   for my $col ($col0 .. $col1)
   {
       my($x,$y) = $self->GridToXY($col,$row);
       my $data = $self->GetRow($row);
       my @pointdata = ($x,$y);
       for( my ($c, $n) = ($col*$nd,0); $n < $nd; $c++, $n++ )
       {
           push(@pointdata,defined($data->[$c]) ? $data->[$c]*$self->{vres} : undef);
       }
       push(@result,\@pointdata);
   }

   return wantarray ? @result : \@result;
   }


sub GridToXY {
   my ($self,$col,$row) = @_;
   my $x = $self->{xmin} + $col*$self->{xres};
   my $y = $self->{ymin} + $row*$self->{yres};
   return ($x,$y);
   }


sub Dimension {
   my ($self) = @_;
   return $self->{nval};
   }
  
sub XYToGrid {
   my( $self, $x, $y ) = @_;
   $x -= $self->{xmin};
   if( $self->{latlon} ) {
     $x -= 360.0 while $x > 360;
     $x += 360.0 while $x < 0;
     }
   $x /= $self->{xres};
   $y = ($y - $self->{ymin}) / $self->{yres};
   return ($x, $y);
   }
   
sub LinearFactors {
   my( $x ,$max, $global ) = @_;
   die "Coordinates out of range for grid\n" if
     ! $global && ($x < 0 || $x > $max-1);
   my $r = int($x);
   $r-- if $r > $x;
   $x -= $r;
   $r %= $max;
   my $r1 = ($r+1) % $max;
   return ($r, 1-$x, $r1, $x );
   }

sub CalcLinear {
   my( $self, $x, $y) = @_;
   ($x,$y) = $self->XYToGrid($x,$y);
   my $nval = $self->{nval};
   my @xi = &LinearFactors( $x, $self->{ngridx}, $self->{global} );
   my @yi = &LinearFactors( $y, $self->{ngridy} );
   my ($ix, $iy);
   my @val;
   for( $iy = 0; $iy < $#yi; $iy+=2 ) {
       my( $row, $ymult ) = @yi[$iy,$iy+1];
       my $data = $self->GetRow($row);
       for( $ix = 0; $ix < $#xi; $ix+=2 ) {
          my( $col, $xmult ) = @xi[$ix,$ix+1];
          $col *= $nval;
          foreach( 0 .. $nval-1 ) {
             my $v = $data->[$col+$_];
             die "Missing data in grid\n" if ! defined($v);
             $val[$_] += $xmult*$ymult*$v;
             }
          }
       }

   return map { $_ *= $self->{vres} } @val;
   }

sub CubicFactors {
   my( $x ,$max, $global ) = @_;
   die "Coordinates out of range for grid\n" if
     ! $global && ($x < 1 || $x > $max-2 );
   my $r = int($x);
   $r-- if $r > $x;
   $x -= $r;
   $x = 2*$x-1;
   my( $x0, $x1, $x2, $x3 ) = ($x+3, $x+1, $x-1, $x-3);
   return (
      ($r-1)%$max, -($x1*$x2*$x3)/48.0,
      $r % $max,    ($x0*$x2*$x3)/16.0,
      ($r+1)%$max, -($x0*$x1*$x3)/16.0,
      ($r+2)%$max,  ($x0*$x1*$x2)/48.0 );
   }


sub CalcCubic {
   my( $self, $x, $y) = @_;
   ($x,$y) = $self->XYToGrid($x,$y);
   my $nval = $self->{nval};
   my @xi = &CubicFactors( $x, $self->{ngridx}, $self->{global} );
   my @yi = &CubicFactors( $y, $self->{ngridy} );
   my ($ix, $iy);
   my @val;
   for( $iy = 0; $iy < $#yi; $iy+=2 ) {
       my( $row, $ymult ) = @yi[$iy,$iy+1];
       my $data = $self->GetRow($row);
       for( $ix = 0; $ix < $#xi; $ix+=2 ) {
          my( $col, $xmult ) = @xi[$ix,$ix+1];
          $col *= $nval;
          foreach( 0 .. $nval-1 ) {
             my $v = $data->[$col+$_];
             die "Missing data in grid\n" if ! defined($v);
             $val[$_] += $xmult*$ymult*$v;
             }
          }
       }

   return map { $_ *= $self->{vres} } @val;
   }


sub Calc {
   my( $self, $x, $y) = @_;
   return $self->CalcLinear($x,$y);
   }

sub Convert
{
    my(@args) = @_;
    @args = @ARGV if ! @args;

    die "Missing arguments for GridFile::Convert\n" if @args < 2;
    my $from = shift @args;
    my $to = shift @args;
    my %options;
    foreach my $a (@args)
    {
        my ($opt,$value) = split(/\=/,$a,2);
        $value = 1 if $value eq '';
        $options{lc($opt)} = $value;
    }
    my $grid = new GridFile($from);
    $grid->WriteToFile($to,%options);
}

1;

__END__

=head1 NAME

GridFile -- Reads, interpolates, writes LINZ grid files

=head1 SYNOPSIS

   use GridFile

   my $grid = new GridFile( filename )
   my $grid = newEmbedded GridFile( filehandle, offset )

   print join("\n",$grid->Title),"\n"
   print $grid->CrdSysCode,"\n"

   my ($xmin,$ymin,$xmax,$ymax) = $grid->Range;
   my ($ngridx, $ngridy ) = $grid->GridSize;
   my ($xres, $yres) = $grid->GridSpacing;
   my ($ndata) = $grid->Dimension;

   # $row is 0 based
   my $rowdata = $grid->RowData($row);
   my($x,$y,@pointdata) = @{$rowdata->[0]};

   my ($x,$y) = $grid->GridToXY($ix,$iy);
   my ($ix,$iy) = $grid->XYToGrid($x,$y);

   eval {
        my @calcl = $grid->CalcLinear($x,$y);
        my @calcc = $grid->CalcCubic($x,$y);
        };

   $grid->WriteToFile( $filename, %options );
   # Options:
   #    format=>GRID2L,..., or ASCII, CSV
   #    vres=>resolution (0 = select optimal value)
   #    real=>1 (ASCII only)
   #    headeronly=>1 (ASCII only)
   #    separator=>c (CSV only, use "tab" for tab)
   #    header=>0 (CSV only)
   #    header=>'column headers' (CSV only)
   #    missingvalue=>$v (CSV only)
   #    skipmssingvalues=>1 (CSV only)

   perl -MGridFile -e GridFile::Convert source.grd target.grd format=GRID2L

=head1 ASCII GRID FORMAT

Grids are usually stored in binary format for efficient processing.  Ascii format
is used for generating and archiving grid information.  The ascii format is:

  COMMENT: ... ignored
  FORMAT: GRID1L
  HEADER0: First line of grid title
  HEADER1: Second line of grid title
  HEADER2: Third line of grid title
  CRDSYS:  NZGD2000
  NGRDX: 7
  NGRDY: 6
  XMIN: 166
  XMAX: 178
  YMIN: -45
  YMAX: -35
  VRES: 2e-006
  NDIM: 2
  LATLON: 1
  VALUES: REAL
  V1,1: 2.288 47.453
  V2,1: 23.676 39.044
  V3,1: 30.197 34.079y
  V4,1: 34.523 33.036
  V5,1: * *
  V6,1: * *
  V7,1: * *
  V1,2: * *
  V2,2: * *
  V3,2: 3.063 46.443
  ...
  V5,6: 6.278 43.263
  V6,6: * *
  V7,6: * *

In this format NGRDX and NGRDY are the number of grid vertices in the X (longitude)
and Y (latitude) directions.  XMIN and XMAX are the minimum and maximum X values,
YMIN and YMAX are the minimum and maximum Y values.  VRES is the data value 
resolution - data values are stored as integers that are multiplied by this value.
Use VRES = 0 or AUTO to automatically calculate a value.
NDIM is the number of data values at each grid point.  LATLON is 1 if X and Y values
are latitude and longitude (so that they can wrap around at 360 degrees), and VALUESis REAL or INTEGER.  If it is INTEGER then the VRES resolution has already been
applied. FORMAT defines the intended binary format - see below.

Data values are listed row by row as 

   V(c,r): d1 d2

Where c is the column number (X grid point number), starting at 1 in the east, and
r is the row number (Y grid point number) starting at 1 in the south. d1, d2, .. 
are the NDIM data values at each point.  Unknown values are represented as '*'


=head1 BINARY FORMATS

=over

=item GEOID

Legacy format - only one data item at each grid point. Little endian format only.

=item GRID1L, GRID1B

Little and big endian formats.  Simple 2 byte signed integer value for each data
value. 

=item GRID2L, GRID2B

Little and big endian formats.  Four byte signed integer value for each data
point.  Data may be compressed data using differencing along rows to reduce to
1, 2 or 4 byte values for each data point.

=back

=head1 TODO

This module really needs refactoring to abstract out generic grid functionality and
move format specific functions into subclasses.  Also separate out reading/writing
code to avoid loading writing when not needed, possibly also separate out
calculation code.  Most member functions need a better name!

The BuildRowV2 function should be enhanced to break up rows into sections of
different compression scheme rather than using one scheme for the entire row.
Note that reading routines already handle this.

